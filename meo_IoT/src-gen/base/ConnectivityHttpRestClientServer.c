/**
 * Generated by Eclipse Mita 0.1.0.
 * @date 2019-11-03 00:58:19
 */


#include <FreeRTOS.h>
#include <BCDS_NetworkConfig.h>
#include <BCDS_Basics.h>
#include <BCDS_ServalPal.h>
#include <BCDS_ServalPalWiFi.h>
#include <semphr.h>
#include <stdio.h>
#include <Serval_Http.h>
#include <inttypes.h>
#include <Serval_Network.h>
#include <Serval_HttpClient.h>
#include <BCDS_Retcode.h>
#include "MitaExceptions.h"

#define TASK_PRIORITY_SERVALPAL_CMD_PROC            UINT32_C(3)
#define TASK_STACK_SIZE_SERVALPAL_CMD_PROC          UINT32_C(600)
#define TASK_QUEUE_LEN_SERVALPAL_CMD_PROC           UINT32_C(10)
static char httpBodyBuffer[512];
static SemaphoreHandle_t responseReceivedSemaphore;
static Http_StatusCode_T responseStatusCode;
static retcode_t responseRetcode;

#define CONNECTIVITYHTTPRESTCLIENTSERVER_TIMEOUT (20000 / portTICK_PERIOD_MS)
#define CONNECTIVITYHTTPRESTCLIENTSERVER_HOST    "192.168.43.15"

static retcode_t httpPayloadSerializer(OutMsgSerializationHandover_T* omsh_ptr);
static retcode_t httpClientResponseCallback(HttpSession_T *httpSession, Msg_T *msg_ptr, retcode_t status);
static retcode_t httpClientOnSentCallback(Callable_T *callfunc, retcode_t status);

Retcode_T ConnectivityHttpRestClientServer_Setup(void)
{
	Retcode_T exception = RETCODE_OK;
	
	
	/**< Handle for Serval PAL thread command processor */
	static CmdProcessor_T ServalPALCmdProcessorHandle;
	
	exception = CmdProcessor_Initialize(&ServalPALCmdProcessorHandle, "Serval PAL", TASK_PRIORITY_SERVALPAL_CMD_PROC, TASK_STACK_SIZE_SERVALPAL_CMD_PROC, TASK_QUEUE_LEN_SERVALPAL_CMD_PROC);
	
	if (RETCODE_OK == exception)
	{
		exception = ServalPal_Initialize(&ServalPALCmdProcessorHandle);
	}
	if (RETCODE_OK == exception)
	{
		exception = ServalPalWiFi_Init();
	}
	
	
	responseReceivedSemaphore = xSemaphoreCreateBinary();
	
	return NO_EXCEPTION;
}

Retcode_T ConnectivityHttpRestClientServer_Enable(void)
{
	Retcode_T exception = RETCODE_OK;
	
	
	if(RETCODE_OK == exception)
	{
		exception = ServalPalWiFi_NotifyWiFiEvent(SERVALPALWIFI_CONNECTED, NULL);
	}
	
	if(RETCODE_OK != exception)
	{
		return exception;
	}
	
	
	exception = HttpClient_initialize();
	if(exception != RETCODE_OK) 
	{
		return exception;
	}
	
	return NO_EXCEPTION;
}

/**
 * Provides read access to the root signal.
 */
Retcode_T ConnectivityHttpRestClientServer_Root_Read(char** result)
{
	return RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_FAILURE);
	
	return NO_EXCEPTION;
}

/**
 * Provides write access to the root signal.
 */
Retcode_T ConnectivityHttpRestClientServer_Root_Write(char** value)
{
	size_t messageLength = strlen((const char*) *value) + 1;
	if(messageLength > sizeof(httpBodyBuffer))
	{
		return EXCEPTION_INDEXOUTOFBOUNDSEXCEPTION;
	}
	
	memcpy(httpBodyBuffer, *value, messageLength);
	
	Retcode_T exception = RETCODE_OK;
	Ip_Address_T destAddr;
	exception = NetworkConfig_GetIpAddress((uint8_t*) CONNECTIVITYHTTPRESTCLIENTSERVER_HOST, &destAddr);
	if (exception != RETCODE_OK)
	{
		return exception;
	}
	
	retcode_t rc;
	Msg_T* msg_ptr;
	rc = HttpClient_initRequest(&destAddr, Ip_convertIntToPort(1234), &msg_ptr);
	if (rc != RC_OK || msg_ptr == NULL)
	{
	    return rc;
	}
	
	HttpMsg_setReqMethod(msg_ptr, Http_Method_Post);
	
	rc = HttpMsg_setHost(msg_ptr, CONNECTIVITYHTTPRESTCLIENTSERVER_HOST);
	if (rc != RC_OK)
	{
	    return rc;
	}
	
	const char* url_ptr = "/iot/";
	rc = HttpMsg_setReqUrl(msg_ptr, url_ptr);
	if (rc != RC_OK)
	{
	    return rc;
	}
	
	HttpMsg_setContentType(msg_ptr, "application/json");
	rc = Msg_prependPartFactory(msg_ptr, &httpPayloadSerializer);
	if (rc != RC_OK) {
		return rc;
	}
	
	Callable_T sentCallable;
	(void) Callable_assign(&sentCallable, httpClientOnSentCallback);
	rc = HttpClient_pushRequest(msg_ptr, &sentCallable, &httpClientResponseCallback);
	if (rc != RC_OK)
	{
		return rc;
	}
	
	if(xSemaphoreTake(responseReceivedSemaphore, CONNECTIVITYHTTPRESTCLIENTSERVER_TIMEOUT) == pdTRUE)
	{
		if(responseRetcode != RC_OK) {
			return EXCEPTION_HTTPREQUESTNOTOKEXCEPTION;
		}
		else if(responseStatusCode == Http_StatusCode_OK)
		{
			return RC_OK;
		}
		else
		{
			printf("[WARNING, %s:%d] HTTP response status code was %d\n", __FILE__, __LINE__, responseStatusCode);
			return EXCEPTION_HTTPREQUESTNOTOKEXCEPTION;
		}
	} 
	else
	{
		printf("[WARNING, %s:%d] HTTP request timed out\n", __FILE__, __LINE__);
		return EXCEPTION_TIMEOUTEXCEPTION;
	}
	
	return NO_EXCEPTION;
}


/**
 * @brief API responsible to pass the payload to the requested URL
 *
 * @param[in] omsh_ptr This data structure is used hold the buffer and information needed by the serializer.
 *
 */
static retcode_t httpPayloadSerializer(OutMsgSerializationHandover_T* omsh_ptr)
{
    uint32_t offset = omsh_ptr->offset;
    uint32_t bytesLeft = strlen(httpBodyBuffer) - offset;
    uint32_t bytesToCopy = omsh_ptr->bufLen > bytesLeft ? bytesLeft : omsh_ptr->bufLen;

    memcpy(omsh_ptr->buf_ptr, httpBodyBuffer + offset, bytesToCopy);
    omsh_ptr->len = bytesToCopy;

    if(bytesToCopy < bytesLeft) {
    	return RC_MSG_FACTORY_INCOMPLETE;
    } else {
    	return RC_OK;
    }
}

static retcode_t httpClientResponseCallback(HttpSession_T *httpSession, Msg_T *msg_ptr, retcode_t status) 
{
	responseRetcode = status;
	responseStatusCode = HttpMsg_getStatusCode(msg_ptr);
	xSemaphoreGive(responseReceivedSemaphore);
	return RC_OK;
}


static retcode_t httpClientOnSentCallback(Callable_T *callfunc, retcode_t status) {
	printf("[DEBUG, %s:%d] Send HTTP request %s\n", __FILE__, __LINE__, (status == RC_OK ? "OK" : "FAILED"));
	return status;
}

